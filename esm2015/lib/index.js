import deepmerge from 'deepmerge';
import { INIT as INIT_ACTION, UPDATE as UPDATE_ACTION } from '@ngrx/store';
const detectDate = /(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})/;
// correctly parse dates from local storage
export const dateReviver = (_key, value) => {
    if (typeof value === 'string' && detectDate.test(value)) {
        return new Date(value);
    }
    return value;
};
const dummyReviver = (_key, value) => value;
const checkIsBrowserEnv = () => {
    return typeof window !== 'undefined';
};
const validateStateKeys = (keys) => {
    return keys.map((key) => {
        let attr = key;
        if (typeof key === 'object') {
            attr = Object.keys(key)[0];
        }
        if (typeof attr !== 'string') {
            throw new TypeError(`localStorageSync Unknown Parameter Type: ` + `Expected type of string, got ${typeof attr}`);
        }
        return key;
    });
};
export const rehydrateApplicationState = (keys, storage, storageKeySerializer, restoreDates) => {
    return keys.reduce((acc, curr) => {
        let key = curr;
        let reviver = restoreDates ? dateReviver : dummyReviver;
        let deserialize;
        let decrypt;
        if (typeof key === 'object') {
            key = Object.keys(key)[0];
            // use the custom reviver function
            if (typeof curr[key] === 'function') {
                reviver = curr[key];
            }
            else {
                // use custom reviver function if available
                if (curr[key].reviver) {
                    reviver = curr[key].reviver;
                }
                // use custom serialize function if available
                if (curr[key].deserialize) {
                    deserialize = curr[key].deserialize;
                }
            }
            // Ensure that encrypt and decrypt functions are both present
            if (curr[key].encrypt && curr[key].decrypt) {
                if (typeof curr[key].encrypt === 'function' && typeof curr[key].decrypt === 'function') {
                    decrypt = curr[key].decrypt;
                }
                else {
                    console.error(`Either encrypt or decrypt is not a function on '${curr[key]}' key object.`);
                }
            }
            else if (curr[key].encrypt || curr[key].decrypt) {
                // Let know that one of the encryption functions is not provided
                console.error(`Either encrypt or decrypt function is not present on '${curr[key]}' key object.`);
            }
        }
        if (storage !== undefined) {
            let stateSlice = storage.getItem(storageKeySerializer(key));
            if (stateSlice) {
                // Use provided decrypt function
                if (decrypt) {
                    stateSlice = decrypt(stateSlice);
                }
                const isObjectRegex = new RegExp('{|\\[');
                let raw = stateSlice;
                if (stateSlice === 'null' || stateSlice === 'true' || stateSlice === 'false' || isObjectRegex.test(stateSlice.charAt(0))) {
                    raw = JSON.parse(stateSlice, reviver);
                }
                return Object.assign({}, acc, {
                    [key]: deserialize ? deserialize(raw) : raw,
                });
            }
        }
        return acc;
    }, {});
};
// Recursively traverse all properties of the existing slice as defined by the `filter` argument,
// and output the new object with extraneous properties removed.
function createStateSlice(existingSlice, filter) {
    return filter.reduce((memo, attr) => {
        if (typeof attr === 'string' || typeof attr === 'number') {
            const value = existingSlice === null || existingSlice === void 0 ? void 0 : existingSlice[attr];
            if (value !== undefined) {
                memo[attr] = value;
            }
        }
        else {
            for (const key in attr) {
                if (Object.prototype.hasOwnProperty.call(attr, key)) {
                    const element = attr[key];
                    memo[key] = createStateSlice(existingSlice[key], element);
                }
            }
        }
        return memo;
    }, {});
}
export const syncStateUpdate = (state, keys, storage, storageKeySerializer, removeOnUndefined, syncCondition) => {
    if (syncCondition) {
        try {
            if (syncCondition(state) !== true) {
                return;
            }
        }
        catch (e) {
            // Treat TypeError as do not sync
            if (e instanceof TypeError) {
                return;
            }
            throw e;
        }
    }
    keys.forEach((key) => {
        let stateSlice = state[key];
        let replacer;
        let space;
        let encrypt;
        if (typeof key === 'object') {
            let name = Object.keys(key)[0];
            stateSlice = state[name];
            if (typeof stateSlice !== 'undefined' && key[name]) {
                // use serialize function if specified.
                if (key[name].serialize) {
                    stateSlice = key[name].serialize(stateSlice);
                }
                else {
                    // if serialize function is not specified filter on fields if an array has been provided.
                    let filter;
                    if (key[name].reduce) {
                        filter = key[name];
                    }
                    else if (key[name].filter) {
                        filter = key[name].filter;
                    }
                    if (filter) {
                        stateSlice = createStateSlice(stateSlice, filter);
                    }
                    // Check if encrypt and decrypt are present, also checked at this#rehydrateApplicationState()
                    if (key[name].encrypt && key[name].decrypt) {
                        if (typeof key[name].encrypt === 'function') {
                            encrypt = key[name].encrypt;
                        }
                    }
                    else if (key[name].encrypt || key[name].decrypt) {
                        // If one of those is not present, then let know that one is missing
                        console.error(`Either encrypt or decrypt function is not present on '${key[name]}' key object.`);
                    }
                }
                /*
          Replacer and space arguments to pass to JSON.stringify.
          If these fields don't exist, undefined will be passed.
        */
                replacer = key[name].replacer;
                space = key[name].space;
            }
            key = name;
        }
        if (typeof stateSlice !== 'undefined' && storage !== undefined) {
            try {
                if (encrypt) {
                    // ensure that a string message is passed
                    stateSlice = encrypt(typeof stateSlice === 'string' ? stateSlice : JSON.stringify(stateSlice, replacer, space));
                }
                storage.setItem(storageKeySerializer(key), typeof stateSlice === 'string' ? stateSlice : JSON.stringify(stateSlice, replacer, space));
            }
            catch (e) {
                console.warn('Unable to save state to localStorage:', e);
            }
        }
        else if (typeof stateSlice === 'undefined' && removeOnUndefined) {
            try {
                storage.removeItem(storageKeySerializer(key));
            }
            catch (e) {
                console.warn(`Exception on removing/cleaning undefined '${key}' state`, e);
            }
        }
    });
};
// Default merge strategy is a full deep merge.
export const defaultMergeReducer = (state, rehydratedState, action) => {
    if ((action.type === INIT_ACTION || action.type === UPDATE_ACTION) && rehydratedState) {
        const overwriteMerge = (destinationArray, sourceArray, options) => sourceArray;
        const options = {
            arrayMerge: overwriteMerge,
        };
        state = deepmerge(state, rehydratedState, options);
    }
    return state;
};
export const localStorageSync = (config) => (reducer) => {
    if ((config.storage === undefined && !config.checkStorageAvailability) ||
        (config.checkStorageAvailability && checkIsBrowserEnv())) {
        config.storage = localStorage || window.localStorage;
    }
    if (config.storageKeySerializer === undefined) {
        config.storageKeySerializer = (key) => key;
    }
    if (config.restoreDates === undefined) {
        config.restoreDates = true;
    }
    // Use default merge reducer.
    let mergeReducer = config.mergeReducer;
    if (mergeReducer === undefined || typeof mergeReducer !== 'function') {
        mergeReducer = defaultMergeReducer;
    }
    const stateKeys = validateStateKeys(config.keys);
    const rehydratedState = config.rehydrate
        ? rehydrateApplicationState(stateKeys, config.storage, config.storageKeySerializer, config.restoreDates)
        : undefined;
    return function (state, action) {
        let nextState;
        // If state arrives undefined, we need to let it through the supplied reducer
        // in order to get a complete state as defined by user
        if (action.type === INIT_ACTION && !state) {
            nextState = reducer(state, action);
        }
        else {
            nextState = Object.assign({}, state);
        }
        // Merge the store state with the rehydrated state using
        // either a user-defined reducer or the default.
        nextState = mergeReducer(nextState, rehydratedState, action);
        nextState = reducer(nextState, action);
        if (action.type !== INIT_ACTION) {
            syncStateUpdate(nextState, stateKeys, config.storage, config.storageKeySerializer, config.removeOnUndefined, config.syncCondition);
        }
        return nextState;
    };
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9wcm9qZWN0cy9saWIvc3JjL2xpYi9pbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLFNBQVMsTUFBTSxXQUFXLENBQUM7QUFDbEMsT0FBTyxFQUNILElBQUksSUFBSSxXQUFXLEVBQ25CLE1BQU0sSUFBSSxhQUFhLEVBQzFCLE1BQU0sYUFBYSxDQUFDO0FBRXJCLE1BQU0sVUFBVSxHQUFHLGlEQUFpRCxDQUFDO0FBRXJFLDJDQUEyQztBQUMzQyxNQUFNLENBQUMsTUFBTSxXQUFXLEdBQUcsQ0FBQyxJQUFZLEVBQUUsS0FBVSxFQUFFLEVBQUU7SUFDcEQsSUFBSSxPQUFPLEtBQUssS0FBSyxRQUFRLElBQUksVUFBVSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRTtRQUNyRCxPQUFPLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO0tBQzFCO0lBQ0QsT0FBTyxLQUFLLENBQUM7QUFDakIsQ0FBQyxDQUFDO0FBRUYsTUFBTSxZQUFZLEdBQUcsQ0FBQyxJQUFZLEVBQUUsS0FBVSxFQUFFLEVBQUUsQ0FBQyxLQUFLLENBQUM7QUFFekQsTUFBTSxpQkFBaUIsR0FBRyxHQUFHLEVBQUU7SUFDM0IsT0FBTyxPQUFPLE1BQU0sS0FBSyxXQUFXLENBQUM7QUFDekMsQ0FBQyxDQUFDO0FBRUYsTUFBTSxpQkFBaUIsR0FBRyxDQUFDLElBQVUsRUFBRSxFQUFFO0lBQ3JDLE9BQVEsSUFBYyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFO1FBQy9CLElBQUksSUFBSSxHQUFHLEdBQUcsQ0FBQztRQUVmLElBQUksT0FBTyxHQUFHLEtBQUssUUFBUSxFQUFFO1lBQ3pCLElBQUksR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQzlCO1FBRUQsSUFBSSxPQUFPLElBQUksS0FBSyxRQUFR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QixDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNqRCxNQUFNLGVBQWUsR0FBRyxNQUFNLENBQUMsU0FBUztRQUNwQyxDQUFDLENBQUMseUJBQXlCLENBQUMsU0FBUyxFQUFFLE1BQU0sQ0FBQyxPQUFPLEVBQUUsTUFBTSxDQUFDLG9CQUFvQixFQUFFLE1BQU0sQ0FBQyxZQUFZLENBQUM7UUFDeEcsQ0FBQyxDQUFDLFNBQVMsQ0FBQztJQUVoQixPQUFPLFVBQVUsS0FBVSxFQUFFLE1BQVc7UUFDcEMsSUFBSSxTQUFjLENBQUM7UUFFbkIsNkVBQTZFO1FBQzdFLHNEQUFzRDtRQUN0RCxJQUFJLE1BQU0sQ0FBQyxJQUFJLEtBQUssV0FBVyxJQUFJLENBQUMsS0FBSyxFQUFFO1lBQ3ZDLFNBQVMsR0FBRyxPQUFPLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxDQUFDO1NBQ3RDO2FBQU07WUFDSCxTQUFTLHFCQUFRLEtBQUssQ0FBRSxDQUFDO1NBQzVCO1FBRUQsd0RBQXdEO1FBQ3hELGdEQUFnRDtRQUNoRCxTQUFTLEdBQUcsWUFBWSxDQUFDLFNBQVMsRUFBRSxlQUFlLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFFN0QsU0FBUyxHQUFHLE9BQU8sQ0FBQyxTQUFTLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFFdkMsSUFBSSxNQUFNLENBQUMsSUFBSSxLQUFLLFdBQVcsRUFBRTtZQUM3QixlQUFlLENBQ1gsU0FBUyxFQUNULFNBQVMsRUFDVCxNQUFNLENBQUMsT0FBTyxFQUNkLE1BQU0sQ0FBQyxvQkFBd0QsRUFDL0QsTUFBTSxDQUFDLGlCQUFpQixFQUN4QixNQUFNLENBQUMsYUFBYSxDQUN2QixDQUFDO1NBQ0w7UUFFRCxPQUFPLFNBQVMsQ0FBQztJQUNyQixDQUFDLENBQUM7QUFDTixDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZGVlcG1lcmdlIGZyb20gJ2RlZXBtZXJnZSc7XG5pbXBvcnQge1xuICAgIElOSVQgYXMgSU5JVF9BQ1RJT04sXG4gICAgVVBEQVRFIGFzIFVQREFURV9BQ1RJT05cbn0gZnJvbSAnQG5ncngvc3RvcmUnO1xuXG5jb25zdCBkZXRlY3REYXRlID0gLyhcXGR7NH0pLShcXGR7Mn0pLShcXGR7Mn0pVChcXGR7Mn0pOihcXGR7Mn0pOihcXGR7Mn0pLztcblxuLy8gY29ycmVjdGx5IHBhcnNlIGRhdGVzIGZyb20gbG9jYWwgc3RvcmFnZVxuZXhwb3J0IGNvbnN0IGRhdGVSZXZpdmVyID0gKF9rZXk6IHN0cmluZywgdmFsdWU6IGFueSkgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIGRldGVjdERhdGUudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcblxuY29uc3QgZHVtbXlSZXZpdmVyID0gKF9rZXk6IHN0cmluZywgdmFsdWU6IGFueSkgPT4gdmFsdWU7XG5cbmNvbnN0IGNoZWNrSXNCcm93c2VyRW52ID0gKCkgPT4ge1xuICAgIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcbn07XG5cbmNvbnN0IHZhbGlkYXRlU3RhdGVLZXlzID0gKGtleXM6IEtleXMpID0+IHtcbiAgICByZXR1cm4gKGtleXMgYXMgYW55W10pLm1hcCgoa2V5KSA9PiB7XG4gICAgICAgIGxldCBhdHRyID0ga2V5O1xuXG4gICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgYXR0ciA9IE9iamVjdC5rZXlzKGtleSlbMF07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGF0dHIgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICAgIGBsb2NhbFN0b3JhZ2VTeW5jIFVua25vd24gUGFyYW1ldGVyIFR5cGU6IGAgKyBgRXhwZWN0ZWQgdHlwZSBvZiBzdHJpbmcsIGdvdCAke3R5cGVvZiBhdHRyfWBcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGtleTtcbiAgICB9KTtcbn07XG5cbmV4cG9ydCBjb25zdCByZWh5ZHJhdGVBcHBsaWNhdGlvblN0YXRlID0gKFxuICAgIGtleXM6IEtleXMsXG4gICAgc3RvcmFnZTogU3RvcmFnZSxcbiAgICBzdG9yYWdlS2V5U2VyaWFsaXplcjogKGtleTogc3RyaW5nKSA9PiBzdHJpbmcsXG4gICAgcmVzdG9yZURhdGVzOiBib29sZWFuXG4pID0+IHtcbiAgICByZXR1cm4gKGtleXMgYXMgYW55W10pLnJlZHVjZSgoYWNjLCBjdXJyKSA9PiB7XG4gICAgICAgIGxldCBrZXkgPSBjdXJyO1xuICAgICAgICBsZXQgcmV2aXZlciA9IHJlc3RvcmVEYXRlcyA/IGRhdGVSZXZpdmVyIDogZHVtbXlSZXZpdmVyO1xuICAgICAgICBsZXQgZGVzZXJpYWxpemU6IChhcmcwOiBzdHJpbmcpID0+IGFueTtcbiAgICAgICAgbGV0IGRlY3J5cHQ6IChhcmcwOiBzdHJpbmcpID0+IHN0cmluZztcblxuICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGtleSA9IE9iamVjdC5rZXlzKGtleSlbMF07XG4gICAgICAgICAgICAvLyB1c2UgdGhlIGN1c3RvbSByZXZpdmVyIGZ1bmN0aW9uXG4gICAgICAgICAgICBpZiAodHlwZW9mIGN1cnJba2V5XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJldml2ZXIgPSBjdXJyW2tleV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHVzZSBjdXN0b20gcmV2aXZlciBmdW5jdGlvbiBpZiBhdmFpbGFibGVcbiAgICAgICAgICAgICAgICBpZiAoY3VycltrZXldLnJldml2ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV2aXZlciA9IGN1cnJba2V5XS5yZXZpdmVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyB1c2UgY3VzdG9tIHNlcmlhbGl6ZSBmdW5jdGlvbiBpZiBhdmFpbGFibGVcbiAgICAgICAgICAgICAgICBpZiAoY3VycltrZXldLmRlc2VyaWFsaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlc2VyaWFsaXplID0gY3VycltrZXldLmRlc2VyaWFsaXplO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRW5zdXJlIHRoYXQgZW5jcnlwdCBhbmQgZGVjcnlwdCBmdW5jdGlvbnMgYXJlIGJvdGggcHJlc2VudFxuICAgICAgICAgICAgaWYgKGN1cnJba2V5XS5lbmNyeXB0ICYmIGN1cnJba2V5XS5kZWNyeXB0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjdXJyW2tleV0uZW5jcnlwdCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgY3VycltrZXldLmRlY3J5cHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVjcnlwdCA9IGN1cnJba2V5XS5kZWNyeXB0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVpdGhlciBlbmNyeXB0IG9yIGRlY3J5cHQgaXMgbm90IGEgZnVuY3Rpb24gb24gJyR7Y3VycltrZXldfScga2V5IG9iamVjdC5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJba2V5XS5lbmNyeXB0IHx8IGN1cnJba2V5XS5kZWNyeXB0KSB7XG4gICAgICAgICAgICAgICAgLy8gTGV0IGtub3cgdGhhdCBvbmUgb2YgdGhlIGVuY3J5cHRpb24gZnVuY3Rpb25zIGlzIG5vdCBwcm92aWRlZFxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVpdGhlciBlbmNyeXB0IG9yIGRlY3J5cHQgZnVuY3Rpb24gaXMgbm90IHByZXNlbnQgb24gJyR7Y3VycltrZXldfScga2V5IG9iamVjdC5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RvcmFnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsZXQgc3RhdGVTbGljZSA9IHN0b3JhZ2UuZ2V0SXRlbShzdG9yYWdlS2V5U2VyaWFsaXplcihrZXkpKTtcbiAgICAgICAgICAgIGlmIChzdGF0ZVNsaWNlKSB7XG4gICAgICAgICAgICAgICAgLy8gVXNlIHByb3ZpZGVkIGRlY3J5cHQgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICBpZiAoZGVjcnlwdCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZVNsaWNlID0gZGVjcnlwdChzdGF0ZVNsaWNlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBpc09iamVjdFJlZ2V4ID0gbmV3IFJlZ0V4cCgne3xcXFxcWycpO1xuICAgICAgICAgICAgICAgIGxldCByYXcgPSBzdGF0ZVNsaWNlO1xuXG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlU2xpY2UgPT09ICdudWxsJyB8fCBzdGF0ZVNsaWNlID09PSAndHJ1ZScgfHwgc3RhdGVTbGljZSA9PT0gJ2ZhbHNlJyB8fCBpc09iamVjdFJlZ2V4LnRlc3Qoc3RhdGVTbGljZS5jaGFyQXQoMCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJhdyA9IEpTT04ucGFyc2Uoc3RhdGVTbGljZSwgcmV2aXZlcik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGFjYywge1xuICAgICAgICAgICAgICAgICAgICBba2V5XTogZGVzZXJpYWxpemUgPyBkZXNlcmlhbGl6ZShyYXcpIDogcmF3LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xufTtcblxuLy8gUmVjdXJzaXZlbHkgdHJhdmVyc2UgYWxsIHByb3BlcnRpZXMgb2YgdGhlIGV4aXN0aW5nIHNsaWNlIGFzIGRlZmluZWQgYnkgdGhlIGBmaWx0ZXJgIGFyZ3VtZW50LFxuLy8gYW5kIG91dHB1dCB0aGUgbmV3IG9iamVjdCB3aXRoIGV4dHJhbmVvdXMgcHJvcGVydGllcyByZW1vdmVkLlxuZnVuY3Rpb24gY3JlYXRlU3RhdGVTbGljZShleGlzdGluZ1NsaWNlOiBhbnksIGZpbHRlcjogKHN0cmluZyB8IG51bWJlciB8IEtleUNvbmZpZ3VyYXRpb24gfCBPcHRpb25zKVtdKSB7XG4gICAgcmV0dXJuIGZpbHRlci5yZWR1Y2UoXG4gICAgICAgIChtZW1vOiB7IFt4OiBzdHJpbmddOiBhbnk7IFt4OiBudW1iZXJdOiBhbnkgfSwgYXR0cjogc3RyaW5nIHwgbnVtYmVyIHwgS2V5Q29uZmlndXJhdGlvbiB8IE9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYXR0ciA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGF0dHIgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBleGlzdGluZ1NsaWNlPy5bYXR0cl07XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVtb1thdHRyXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gYXR0cikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHIsIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBhdHRyW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICBtZW1vW2tleV0gPSBjcmVhdGVTdGF0ZVNsaWNlKGV4aXN0aW5nU2xpY2Vba2V5XSwgZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVtbztcbiAgICAgICAgfSxcbiAgICAgICAge31cbiAgICApO1xufVxuXG5leHBvcnQgY29uc3Qgc3luY1N0YXRlVXBkYXRlID0gKFxuICAgIHN0YXRlOiBhbnksXG4gICAga2V5czogS2V5cyxcbiAgICBzdG9yYWdlOiBTdG9yYWdlLFxuICAgIHN0b3JhZ2VLZXlTZXJpYWxpemVyOiAoa2V5OiBzdHJpbmcgfCBudW1iZXIpID0+IHN0cmluZyxcbiAgICByZW1vdmVPblVuZGVmaW5lZDogYm9vbGVhbixcbiAgICBzeW5jQ29uZGl0aW9uPzogKHN0YXRlOiBhbnkpID0+IGFueVxuKSA9PiB7XG4gICAgaWYgKHN5bmNDb25kaXRpb24pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChzeW5jQ29uZGl0aW9uKHN0YXRlKSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gVHJlYXQgVHlwZUVycm9yIGFzIGRvIG5vdCBzeW5jXG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIFR5cGVFcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBrZXlzLmZvckVhY2goKGtleTogc3RyaW5nIHwgS2V5Q29uZmlndXJhdGlvbiB8IE9wdGlvbnMgfCAoKGtleTogc3RyaW5nLCB2YWx1ZTogYW55KSA9PiBhbnkpKTogdm9pZCA9PiB7XG4gICAgICAgIGxldCBzdGF0ZVNsaWNlID0gc3RhdGVba2V5IGFzIHN0cmluZ107XG4gICAgICAgIGxldCByZXBsYWNlcjtcbiAgICAgICAgbGV0IHNwYWNlOiBzdHJpbmcgfCBudW1iZXI7XG4gICAgICAgIGxldCBlbmNyeXB0O1xuXG4gICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgbGV0IG5hbWUgPSBPYmplY3Qua2V5cyhrZXkpWzBdO1xuICAgICAgICAgICAgc3RhdGVTbGljZSA9IHN0YXRlW25hbWVdO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHN0YXRlU2xpY2UgIT09ICd1bmRlZmluZWQnICYmIGtleVtuYW1lXSkge1xuICAgICAgICAgICAgICAgIC8vIHVzZSBzZXJpYWxpemUgZnVuY3Rpb24gaWYgc3BlY2lmaWVkLlxuICAgICAgICAgICAgICAgIGlmIChrZXlbbmFtZV0uc2VyaWFsaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlU2xpY2UgPSBrZXlbbmFtZV0uc2VyaWFsaXplKHN0YXRlU2xpY2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHNlcmlhbGl6ZSBmdW5jdGlvbiBpcyBub3Qgc3BlY2lmaWVkIGZpbHRlciBvbiBmaWVsZHMgaWYgYW4gYXJyYXkgaGFzIGJlZW4gcHJvdmlkZWQuXG4gICAgICAgICAgICAgICAgICAgIGxldCBmaWx0ZXI6IEtleUNvbmZpZ3VyYXRpb25bXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleVtuYW1lXS5yZWR1Y2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlciA9IGtleVtuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChrZXlbbmFtZV0uZmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXIgPSBrZXlbbmFtZV0uZmlsdGVyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWx0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlU2xpY2UgPSBjcmVhdGVTdGF0ZVNsaWNlKHN0YXRlU2xpY2UsIGZpbHRlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBlbmNyeXB0IGFuZCBkZWNyeXB0IGFyZSBwcmVzZW50LCBhbHNvIGNoZWNrZWQgYXQgdGhpcyNyZWh5ZHJhdGVBcHBsaWNhdGlvblN0YXRlKClcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleVtuYW1lXS5lbmNyeXB0ICYmIGtleVtuYW1lXS5kZWNyeXB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGtleVtuYW1lXS5lbmNyeXB0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5jcnlwdCA9IGtleVtuYW1lXS5lbmNyeXB0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGtleVtuYW1lXS5lbmNyeXB0IHx8IGtleVtuYW1lXS5kZWNyeXB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBvbmUgb2YgdGhvc2UgaXMgbm90IHByZXNlbnQsIHRoZW4gbGV0IGtub3cgdGhhdCBvbmUgaXMgbWlzc2luZ1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgRWl0aGVyIGVuY3J5cHQgb3IgZGVjcnlwdCBmdW5jdGlvbiBpcyBub3QgcHJlc2VudCBvbiAnJHtrZXlbbmFtZV19JyBrZXkgb2JqZWN0LmBcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgIFJlcGxhY2VyIGFuZCBzcGFjZSBhcmd1bWVudHMgdG8gcGFzcyB0byBKU09OLnN0cmluZ2lmeS5cbiAgICAgICAgICBJZiB0aGVzZSBmaWVsZHMgZG9uJ3QgZXhpc3QsIHVuZGVmaW5lZCB3aWxsIGJlIHBhc3NlZC5cbiAgICAgICAgKi9cbiAgICAgICAgICAgICAgICByZXBsYWNlciA9IGtleVtuYW1lXS5yZXBsYWNlcjtcbiAgICAgICAgICAgICAgICBzcGFjZSA9IGtleVtuYW1lXS5zcGFjZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAga2V5ID0gbmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygc3RhdGVTbGljZSAhPT0gJ3VuZGVmaW5lZCcgJiYgc3RvcmFnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChlbmNyeXB0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVuc3VyZSB0aGF0IGEgc3RyaW5nIG1lc3NhZ2UgaXMgcGFzc2VkXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlU2xpY2UgPSBlbmNyeXB0KFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHN0YXRlU2xpY2UgPT09ICdzdHJpbmcnID8gc3RhdGVTbGljZSA6IEpTT04uc3RyaW5naWZ5KHN0YXRlU2xpY2UsIHJlcGxhY2VyLCBzcGFjZSlcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RvcmFnZS5zZXRJdGVtKFxuICAgICAgICAgICAgICAgICAgICBzdG9yYWdlS2V5U2VyaWFsaXplcihrZXkgYXMgc3RyaW5nKSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHN0YXRlU2xpY2UgPT09ICdzdHJpbmcnID8gc3RhdGVTbGljZSA6IEpTT04uc3RyaW5naWZ5KHN0YXRlU2xpY2UsIHJlcGxhY2VyLCBzcGFjZSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignVW5hYmxlIHRvIHNhdmUgc3RhdGUgdG8gbG9jYWxTdG9yYWdlOicsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzdGF0ZVNsaWNlID09PSAndW5kZWZpbmVkJyAmJiByZW1vdmVPblVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzdG9yYWdlLnJlbW92ZUl0ZW0oc3RvcmFnZUtleVNlcmlhbGl6ZXIoa2V5IGFzIHN0cmluZykpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgRXhjZXB0aW9uIG9uIHJlbW92aW5nL2NsZWFuaW5nIHVuZGVmaW5lZCAnJHtrZXl9JyBzdGF0ZWAsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59O1xuXG4vLyBEZWZhdWx0IG1lcmdlIHN0cmF0ZWd5IGlzIGEgZnVsbCBkZWVwIG1lcmdlLlxuZXhwb3J0IGNvbnN0IGRlZmF1bHRNZXJnZVJlZHVjZXIgPSAoc3RhdGU6IGFueSwgcmVoeWRyYXRlZFN0YXRlOiBhbnksIGFjdGlvbjogYW55KSA9PiB7XG4gICAgaWYgKChhY3Rpb24udHlwZSA9PT0gSU5JVF9BQ1RJT04gfHwgYWN0aW9uLnR5cGUgPT09IFVQREFURV9BQ1RJT04pICYmIHJlaHlkcmF0ZWRTdGF0ZSkge1xuICAgICAgICBjb25zdCBvdmVyd3JpdGVNZXJnZSA9IChkZXN0aW5hdGlvbkFycmF5OiBhbnksIHNvdXJjZUFycmF5OiBhbnksIG9wdGlvbnM6IGFueSkgPT4gc291cmNlQXJyYXk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnM6IGRlZXBtZXJnZS5PcHRpb25zID0ge1xuICAgICAgICAgICAgYXJyYXlNZXJnZTogb3ZlcndyaXRlTWVyZ2UsXG4gICAgICAgIH07XG5cbiAgICAgICAgc3RhdGUgPSBkZWVwbWVyZ2Uoc3RhdGUsIHJlaHlkcmF0ZWRTdGF0ZSwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0YXRlO1xufTtcblxuZXhwb3J0IGNvbnN0IGxvY2FsU3RvcmFnZVN5bmMgPSAoY29uZmlnOiBMb2NhbFN0b3JhZ2VDb25maWcpID0+IChyZWR1Y2VyOiBhbnkpID0+IHtcbiAgICBpZiAoXG4gICAgICAgIChjb25maWcuc3RvcmFnZSA9PT0gdW5kZWZpbmVkICYmICFjb25maWcuY2hlY2tTdG9yYWdlQXZhaWxhYmlsaXR5KSB8fFxuICAgICAgICAoY29uZmlnLmNoZWNrU3RvcmFnZUF2YWlsYWJpbGl0eSAmJiBjaGVja0lzQnJvd3NlckVudigpKVxuICAgICkge1xuICAgICAgICBjb25maWcuc3RvcmFnZSA9IGxvY2FsU3RvcmFnZSB8fCB3aW5kb3cubG9jYWxTdG9yYWdlO1xuICAgIH1cblxuICAgIGlmIChjb25maWcuc3RvcmFnZUtleVNlcmlhbGl6ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25maWcuc3RvcmFnZUtleVNlcmlhbGl6ZXIgPSAoa2V5KSA9PiBrZXk7XG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZy5yZXN0b3JlRGF0ZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25maWcucmVzdG9yZURhdGVzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBVc2UgZGVmYXVsdCBtZXJnZSByZWR1Y2VyLlxuICAgIGxldCBtZXJnZVJlZHVjZXIgPSBjb25maWcubWVyZ2VSZWR1Y2VyO1xuXG4gICAgaWYgKG1lcmdlUmVkdWNlciA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBtZXJnZVJlZHVjZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgbWVyZ2VSZWR1Y2VyID0gZGVmYXVsdE1lcmdlUmVkdWNlcjtcbiAgICB9XG5cbiAgICBjb25zdCBzdGF0ZUtleXMgPSB2YWxpZGF0ZVN0YXRlS2V5cyhjb25maWcua2V5cyk7XG4gICAgY29uc3QgcmVoeWRyYXRlZFN0YXRlID0gY29uZmlnLnJlaHlkcmF0ZVxuICAgICAgICA/IHJlaHlkcmF0ZUFwcGxpY2F0aW9uU3RhdGUoc3RhdGVLZXlzLCBjb25maWcuc3RvcmFnZSwgY29uZmlnLnN0b3JhZ2VLZXlTZXJpYWxpemVyLCBjb25maWcucmVzdG9yZURhdGVzKVxuICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGU6IGFueSwgYWN0aW9uOiBhbnkpIHtcbiAgICAgICAgbGV0IG5leHRTdGF0ZTogYW55O1xuXG4gICAgICAgIC8vIElmIHN0YXRlIGFycml2ZXMgdW5kZWZpbmVkLCB3ZSBuZWVkIHRvIGxldCBpdCB0aHJvdWdoIHRoZSBzdXBwbGllZCByZWR1Y2VyXG4gICAgICAgIC8vIGluIG9yZGVyIHRvIGdldCBhIGNvbXBsZXRlIHN0YXRlIGFzIGRlZmluZWQgYnkgdXNlclxuICAgICAgICBpZiAoYWN0aW9uLnR5cGUgPT09IElOSVRfQUNUSU9OICYmICFzdGF0ZSkge1xuICAgICAgICAgICAgbmV4dFN0YXRlID0gcmVkdWNlcihzdGF0ZSwgYWN0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5leHRTdGF0ZSA9IHsgLi4uc3RhdGUgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1lcmdlIHRoZSBzdG9yZSBzdGF0ZSB3aXRoIHRoZSByZWh5ZHJhdGVkIHN0YXRlIHVzaW5nXG4gICAgICAgIC8vIGVpdGhlciBhIHVzZXItZGVmaW5lZCByZWR1Y2VyIG9yIHRoZSBkZWZhdWx0LlxuICAgICAgICBuZXh0U3RhdGUgPSBtZXJnZVJlZHVjZXIobmV4dFN0YXRlLCByZWh5ZHJhdGVkU3RhdGUsIGFjdGlvbik7XG5cbiAgICAgICAgbmV4dFN0YXRlID0gcmVkdWNlcihuZXh0U3RhdGUsIGFjdGlvbik7XG5cbiAgICAgICAgaWYgKGFjdGlvbi50eXBlICE9PSBJTklUX0FDVElPTikge1xuICAgICAgICAgICAgc3luY1N0YXRlVXBkYXRlKFxuICAgICAgICAgICAgICAgIG5leHRTdGF0ZSxcbiAgICAgICAgICAgICAgICBzdGF0ZUtleXMsXG4gICAgICAgICAgICAgICAgY29uZmlnLnN0b3JhZ2UsXG4gICAgICAgICAgICAgICAgY29uZmlnLnN0b3JhZ2VLZXlTZXJpYWxpemVyIGFzIChrZXk6IHN0cmluZyB8IG51bWJlcikgPT4gc3RyaW5nLFxuICAgICAgICAgICAgICAgIGNvbmZpZy5yZW1vdmVPblVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBjb25maWcuc3luY0NvbmRpdGlvblxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXh0U3RhdGU7XG4gICAgfTtcbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgTG9jYWxTdG9yYWdlQ29uZmlnIHtcbiAgICBrZXlzOiBLZXlzO1xuICAgIHJlaHlkcmF0ZT86IGJvb2xlYW47XG4gICAgc3RvcmFnZT86IFN0b3JhZ2U7XG4gICAgcmVtb3ZlT25VbmRlZmluZWQ/OiBib29sZWFuO1xuICAgIHJlc3RvcmVEYXRlcz86IGJvb2xlYW47XG4gICAgc3RvcmFnZUtleVNlcmlhbGl6ZXI/OiAoa2V5OiBzdHJpbmcpID0+IHN0cmluZztcbiAgICBzeW5jQ29uZGl0aW9uPzogKHN0YXRlOiBhbnkpID0+IGFueTtcbiAgICBjaGVja1N0b3JhZ2VBdmFpbGFiaWxpdHk/OiBib29sZWFuO1xuICAgIG1lcmdlUmVkdWNlcj86IChzdGF0ZTogYW55LCByZWh5ZHJhdGVkU3RhdGU6IGFueSwgYWN0aW9uOiBhbnkpID0+IGFueTtcbn1cblxuaW50ZXJmYWNlIEtleUNvbmZpZ3VyYXRpb24ge1xuICAgIFtrZXk6IHN0cmluZ106IHN0cmluZ1tdIHwgbnVtYmVyW10gfCBLZXlDb25maWd1cmF0aW9uW10gfCBPcHRpb25zIHwgKChrZXk6IHN0cmluZywgdmFsdWU6IGFueSkgPT4gYW55KTtcbn1cblxuaW50ZXJmYWNlIE9wdGlvbnMge1xuICAgIHNlcmlhbGl6ZT86IChzdGF0ZTogYW55KSA9PiBhbnk7XG4gICAgZGVzZXJpYWxpemU/OiAoc3RhdGU6IGFueSkgPT4gYW55O1xuICAgIHJldml2ZXI/OiAoa2V5OiBzdHJpbmcsIHZhbHVlOiBhbnkpID0+IGFueTtcbiAgICByZXBsYWNlcj86ICgoa2V5OiBzdHJpbmcsIHZhbHVlOiBhbnkpID0+IGFueSkgfCBzdHJpbmdbXTtcbiAgICBlbmNyeXB0PzogKG1lc3NhZ2U6IHN0cmluZykgPT4gc3RyaW5nO1xuICAgIGRlY3J5cHQ/OiAobWVzc2FnZTogc3RyaW5nKSA9PiBzdHJpbmc7XG4gICAgZmlsdGVyPzogc3RyaW5nW107XG4gICAgc3BhY2U/OiBzdHJpbmcgfCBudW1iZXI7XG59XG5cbmV4cG9ydCB0eXBlIEtleXMgPSAoS2V5Q29uZmlndXJhdGlvbiB8IE9wdGlvbnN8IHN0cmluZylbXTtcbiJdfQ==